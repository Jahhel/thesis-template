\chapter{Methode}
\label{chapt:Methode}
\section{Fragestellung}
Aus diesem Grund stellt sich die Frage, ob sich genetische Algorithmen zur Optimierung von Obfuskatorkaskaden unter den Kriterien die für praktische Red Team Assignments relevant sind, als Werkzeug nutzen lassen. Diese Frage speist sich zum einen aus der ungeheuren Prävalenz von Obfuskatoren und Packern in der Bedrohungslage \cite{alkhateeb_2023_a} und auf der anderen Seite den zeitlichen und zum Teil auch ressourcenbedingten Begrenzungen, die ein Red Team einhalten muss (\ref{Methode:Kriterien}). 

Durch Obfuskation steigt zum einen die Größe der Datei und die Entropie innerhalb der Datei, was beides Faktoren sein können, die von AV-Software erkannt und betrachtet werden können.





\section{Verwendete Technologie}
\subsection{Architektur}
Für die Entwicklung der zwei Modi (Dropper und PE File) wurde die Architektur für den genetischen Algorithmus entsprechend angepasst. In \ref{fig:architecture} sieht man die vollständige Architektur, die mittels AWS Services aufgebaut wurde. Sie beinhaltet die AV Scanner und Obfuscator in ihren eigenen Instanzen und den Genetischen Algorithmus in seiner eigenen Instanz. Für die Obfuskation von PE Files werden diese erst an die Obfuskator gesendet, zwischengespeichert und anschließend an die AV Scanner gesendet. Bei dem Shellcode Dropper wird die gleiche Dropper Executable an den AV Scanner gesendet, welcher dann den obfuskierten Shellcode von einem Webserver der GA Instanz herunterlädt und ausführt, während er gescannt wird.
\begin{figure}[h]
    \centering
    \includegraphics[width=0.85\textwidth]{gfx/Abbildungen/Architektur.drawio.png}
    \caption{Architektur von Obscurus Evolved}
    \label{fig:architecture}
\end{figure}
\section{Gütekriterien und Definition}
Eine Obfuscation ist dann gut, wenn sie von AV nicht erkannt wird, ausführbar ist und noch ihren Zweck erfüllt. Eine langsame Erkennung durch AV wird ihr positiv angerechnet. Ein Durchlauf eines Genetischen Algorithmus ist gut, wenn er eine Anzahl von guten Obfuskationen > 0 erzeugt und eine geringe Gesamtlaufzeit hat.
\section{Red-Teaming Kriterien}
Für die praktische Verwendung muss ein solches Tool möglichst autonom und erweiterbar sein. Des Weiteren ist es wichtig, dass es möglich ist weitere Obfuskationsmöglichkeiten und Schritte einzubauen, um mit der weiterentwicklung von Malwaretools Scchritt halten zu können. Eine ebenso wichtige Anforderung ist die Möglichkeit zur Erweiterung anhand von verschiedenen AV Scannern, um verschiedene Workstations, die als Angriffsziel in Frage kommen, simulieren zu können.
Ein essentieller Schritt ist vor allem anderen, aber die Zeitkomponente, da nicht detektierbare Malware für Angriffsszenarien schnell zur Verfügung stehen soll und deshalb weniger als 12 Stunden benötigen muss.

\section{Verwendete Technologien}
    \subsection{Pipeline}
    Obscurus = Internes SAP Tool/Framework zum API Basierten Obfuskieren von Exe und RAW Payloads mittels Obfuskator und Konfiguraionen, sowie einem 
    \subsection{Obfuskatoren}
    Nymcrypt2 und Inceptor
    \subsection{Antivirenscanner}
    Microsoft Defender stuff

\section{Genetischer Algorithmus}
\subsection{Suchproblem Formalisierung}
Um einen genetischen Algorithmus für ein Problem sinnvoll zu verwenden, muss zuerst einmal ein zugrunde liegendes Problem als Suchproblem formuliert werden. Im vorliegenden Anwendungsfall würde eine solche Formalisierung daraus bestehen.
    

Sei $K = \{e_1, e_2, \ldots, e_n\}$ eine Menge von Elementen, wobei jedes Element $e_i$ entweder vom Typ $O$ oder $E$ ist. Gesucht ist eine Konfiguration $K$, sodass die Funktion $f(K)$ maximiert wird.

Der vorhandene genetische Algorithmus wurde auf Basis des vorliegenden Problems mit 2 Obfuskatoren entwickelt und dafür optimiert. Die vorgestellten Obfuskatoren sind dabei als Beispiele für ein Array von verschiedenen Verschleierungsmöglichkeiten und Technologien zu verstehen, die in Kombination eingesetzt werden könnten. Einige Entscheidungen für spezifische genetische Operatoren wurden mittels eines Pretests getroffen \ref{methode:pretest}.

\subsection{Encoding}
Die Lösungskandidaten bestehen aus einer Liste von Obfuskator Konfigurationen. Diese Obfuskatorkonfigurationen beinhalten jeweils alle Eigenschaften, die für jeden der Obfuskatoren als Optionen nötig sind, und benutzen die Eigenschaften, die für den ausgewählten Obfuskator nötig sind. Dies hat zwar zur Folge, dass es starke epigenetische Effekte\footnote{Veränderung eines Genes, die kaskadierende Auswirkungen auf die restlichen Gene im Kandidaten hat} geben und Mutationen völlig ergebnislos bleiben, ermöglicht dafür aber die sinnvolle Verwendung von diversen Rekombinationsarten. Konzeptionell besteht das Encoding damit also aus einem String von gequantelter Größe, die allerdings nicht konstant ist. 
In genetischen Algorithmen ist es eher ungewöhnlich, dass die Länge eines Lösungskandidaten ungleich der von anderen ist, was bei der Rekombination zu Problemen geführt hat. Die Entscheidung für dieses Design liegt darin, dass der Algorithmus von selbst die optimale Obfuskationslänge entscheiden soll und zeitgleich möglichst laufzeiteffizient werden soll.
\begin{figure}[h]
    \centering
    \includegraphics[width=0.85\textwidth]{gfx/Abbildungen/Encoding Diagram.png}
    \caption{Encoding Darstellung}
    \label{fig:encoding}
\end{figure}

\subsection{Selektion}
Für die Selektion wurde im Algorithmus auf die sogenannte Turnierselektion zurückgegriffen, die neben der einfachen Programmierbarkeit es auch leicht macht, den Selektionsdruck anzupassen. \cite{blickle_1996_a} (1995 Tournament Selection and Noise). Ein weiterer Vorteil dieses Verfahrens ist es, dass man nicht die Fitness aller mutierten und rekombinierten Kandidaten einer Population berechnen muss, sondern nur derjenigen, die in einem Turnier teilnehmen. Als weitere Ergänzung und Laufzeitoptimierung kommt der sogenannte "David"-Parameter zum Tragen, welcher dem unterlegenen Kandidaten in einem Turnier als Sieger hervorgehen lässt und so die Diversität der kommenden Generation erhöhen kann.

\subsection{Mutation}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.85\textwidth]{gfx/Abbildungen/Mutations.png}
    \caption{Mutationsmöglichkeiten}
    \label{fig:mutations}
\end{figure}
Die Mutation ist in zwei Bestandteile aufgeteilt. Einerseits eine simple Veränderung einer Obfuskatorkonfiguration innerhalb des Lösungskandidaten und damit innerhalb der Liste. Andererseits das Hinzufügen von einer zufälligen neuen Obfuskatorkonfiguration in den Lösungskandidaten, um so eine längere Lösung zugänglich zu machen.


\subsection{Rekombination}
Für die Rekombination sind viele verschiedene Implementierungen möglich gewesen. Nach einigen Überlegungen wurden dann zwei verschiedene Rekombinationsarten implementiert und ausprobiert.
\subsubsection{String-based-Recombination}
Ähnlich dem klassischen Binary-String Encoding werden hier die Lösungskandidaten an einer beliebigen Stelle durchgeschnitten und die zweite Hälfte zwischen diesen ausgetasucht. Dieser Schnitt kann selbstverständlich an einer Obfuskationskonfigurationsgrenze auftreten und so nur das Stapeln verändert, aber auch innerhalb der Konfiguration.
\subsubsection{Sacrifice Based Shema}
In diesem Beispiel wird von einem Kandidaten eine Konfiguration entfernt und dem anderen Kandidaten hinzugefügt. Dies kann dazu führen, dass eine Lösung keine Obfuskationsschritte beinhaltet und dabei dann als nicht obfuskiertes File behandelt und gescanned wird.



\subsection{Fitness Funktion}
Die Fitness Funktion setzt sich aus mehreren Faktoren zusammen und lässt sich nicht einfach als richtig oder falsch definieren sondern basiert stark auf dem zugrundeliegenden Optimierungsproblem. Das vorliegende Beispiel geht etwas über das Problem von klassischen genetischen Algorithmen hinaus, indem es nicht nur die Kandidaten optimieren soll, sondern zeitgleich auch noch die Laufzeit des gesamten Algorithmus möglichst kurz halten (Hyperparameter).
In diesem Fall gibt es die folgenden Faktoren:

\subsubsection{Obfuskations und Detektions-Dauer}
Wie lange braucht es die die obfuskierte Malware in all ihren Schritten zu erzeugen unter Verwendung von Cashing. Dies ist einer der genannten Hyperparameter, da die gesamte Laufzeit des Algorithmus sich aus der Summe von durchgeführten Obfuskations und Detektionszeiten zusammensetzt und eine Population, die aus Kandidaten besteht, die nur kurze Obfuskations und Detektionsdauern hat, zu einer kürzeren Laufzeit beiträgt. $t_O,  t_D$
\subsubsection{Obfuskationsschritte}
Die Anzahl an Obfuskationsschritten, die der Kandidat behinhaltet. Dies hängt auch stark mit der initalen Population von Kandidaten zusammen und wie häufig diese gestapelt sind \ref{GA:inital_population}. $N_O$
\subsubsection{Detektionsergebnis}
Die Ergebnisse des Scanners, ob die Datei als Malware erkannt wurde und ob der Scanner sie überhaupt durchführen konnte und damit lauffähig ist. $D_{Malicious}=1, D_{Benign}=10^5$

\subsubsection{Funktion}
Die Funktion zeichnet sich durch die oben genannten Hyperparameter aus. Diese sollen zwar nicht für die einzelnen Kandidaten entscheidend sein, dennoch einen Einfluss auf die Gesamtheit der Population haben.

Der Primäre Zweck der Funktion ist es, Malware so zu obfuskieren, dass sie nicht erkannt wird. Sekundär soll dabei die Laufzeit des gesamten Algorithmus klein gehalten werden. Dies kann zu einem Teil durch die Fitnessfunktion bewerkstelligt werden, zum anderen über Caching, welches durch die Fitnessfunktion belohnt werden soll. Andererseits soll für die Analyse der wissenschaftlichen Fragestellung die Verwendung von mehrstufigen Obfuskationen befürwortet werden. Eine Möglichkeit dies zu gewährleisten ist es, dass man die Obfuskationszeit von gecachten nicht künstlich erhöht und nachhält, sondern nur die tatsächlich verbrauchte Zeit bis zum fertig obfuskierten Payload gemessen wird und als $t_O$ interpretiert wird.
Ein weiterer Ansatz, um das Gleichgewicht zwischen Minimierung von Laufzeit und Diversität der Lösungslängen zu wahren, wäre eine T/Z-Transformation der Obfuskationszeiten mit einer angenommenen $\sigma _{t_D}=5s$ und $\overline{M_{t_D}}$

$\frac{D_{Benign, Malicious}}{t_D}+t_O$

\subsection{Startpopulation} \label{GA:inital_population}
Anhand von einigen Versuchen hat sich gezeigt, dass die gängige Praxis von genetischen Algorithmen, eine Populationsgröße von 100 oder größer zu wählen, den Effekt hat, dass die erste Generation eine fast vollständige Auflistung aller Einstelliger Obfuskatorkonfigurationen beinhaltet und somit keinen Vorteil gegenüber einer exhaustive search hat. Aus diesem Grund wurde ein Pretest angesetzt, um Laufzeitverhalten und Diversität innerhalb der Population in Abhängigkeit von verschiedenen Startpopulationsansätzen zu überprüfen und den Vorteil aus dem genetischen Algorithmus zu maximieren.
Deshalb und um \ref{Methode:Kriterien} zu befriedigen, wurde mit der standardmäßigen Populationszahl experimentiert, um den Vorteil von GAs gegenüber einem naiven durchprobieren hervorstechen zu lassen und gleichzeitig eine höhere Dichte von Lösungen mit mehreren Obfuskationsschritten zu haben.
\begin{itemize}
    \item 45 Lösungskandidaten, die zufällig mittels eines Stackingparameters erstellt wurden (Aktuelle Lösung)
    \item 20 Lösungskandidaten, die alle mit maximaler Länge erstellt werden
    \item 20 Lösungskandidaten, die zufällig mittels eines Stackingparameters erstellt wurden
\end{itemize}
\subsubsection{Aufbau Pretest}
Jede Konfiguration wurde mit Bening und Malware einmal durchgeführt und der Verlauf von Rechenzeit, also die Diversität und das Explorations vs Exploitverhalten betrachtet. Ziel ist es, dass die Rechenzeit nicht zu mehr als 80\% in der ersten Generation liegt.
\subsubsection{Ergebnisse}
\begin{table}[]
\begin{tabular}{@{}llll@{}}
\toprule
              & Shell        & Calc & Benign \\ \midrule
45 Random     & 423          & 384  & 621    \\
20 Random     & \textit{180} & 216  & 217    \\
20 Max Length & \textit{196} & \textit{211}  & 209    \\ \bottomrule
\end{tabular}
\caption{Runtimes for different Malware with different starting populations in seconds. Italic means unsucsessfull run}
\label{Pretest_Inital}
\end{table}
Im Pretest hat sich gezeigt, dass die Laufzeit mit der Anzahl zusammenhängt \ref{Pretest_Inital}. In einigen Fällen wurde überhaupt keine Lösung für das Problem gefunden, um die Scanner zu umgehen, diese Lösungen (20-Max-Length und 20-Random für Shell) fallen gänzlich aus dem Test heraus, da sie die grundlegende Funktionalität nicht erfüllen können.

Damit scheiden die Lösungen mit 20 Kandidaten gänzlich aus und wir verbleiben mit der Option von 45 zufälligen Kandidaten mit einem Stackingparamter <1.0.


\section{Experiment}
\label{Experiment}
Der experimentelle Ablauf ist inspiriert von \cite{holm_2023_hide}. 
Anders als dieser Ansatz soll in unserem Algorithmus jedoch nicht (blind) jegliche Konfiguration verwendet und betrachtet werden, sondern nur jene, die vom genetischen Algorithmus erzeugt und selbstständig gescannt wurden, sodass anhand der zwischengespeicherten Daten eine Analyse durchgeführt werden kann.

Aufgrund der Tatsache, dass Malware Erkennung unterschiedlich gut performt, basierend auf der Art von Malware, sollen in diesem Experiment verschiedene Arten von Malware getestet werden. Benignware, Selbstständige Malware und Interactive Malware (Reverse Shell) wurden auch schon von \cite{holm_2023_hide} verwendet, um das System zu überprüfen, weswegen auch hier ein helloworld-Programm, ein mit Metasploit ersteller PE File, welcher mittels der Windows API den Taschenrechner öffnet und einer Reverseshell, welche von Metasploit erstellt wurde verwendet wurde, um die verschiedenen Areale abdecken zui können.

Im Detail sieht der Ablauf also für jede Sampledatei (Helloworld als Benignware, Calc.exe from Metasploit, Reverseshell from Metasploit) wie folgt aus.
\begin{enumerate}
    \item Ausführung des Genetischen Algorithmus
    \item Zählung der erzeugten Dateien
    \item Zählung der ausführbaren Dateien
    \item Zählung der Evaded Dateien
    \item Notation der Evaded Dateien
    \item Löschung der Dateien
\end{enumerate}
Dieser Prozess wird für jedes Sample 3 Mal wiederholt, um eine gewisse Datenmenge vorhanden zu haben.

Aus dem Pretest \ref{Pretest_Inital}, hat sich gezeigt, dass die initale Konfiguration mit 45 Kandidaten, einer Stapelungschance von 70\%, einer Mutationsrate von 5\% und einer Rekombinationsrate von 50\% hilfreiche Ergebnisse liefert. Aus diesem Grund wurden diese Parameter nicht weiter evaluiert, sondern einfach in den Test übernommen.

\section{Hypothesen}
Im Anbetracht der Fragestellung lassen sich schon im Vorfeld einige Vermutungen anstellen, die im Folgenden dargelegt werden sollen.
\subsection{PE-Files}
\textit{Mindestens 5\% der mehrfach obfuskierten PE Files sind korrumpiert und nicht ausführbar.}
Mehrfach obfuskierte PE Files werden wahrscheinlicher von AV-Software entdeckt und/oder anfälliger für Dateikorrumpierung.
PE Files sind lore Ipsum dolor sit. ihre Struktur bla blablabal
\subsection{Shellcode}
\textit{Mehrfach obfuskierter Shellcode ist in weniger fällen als die PE Files korrumpiert und nicht ausführbar.}
Hier wird davon ausgegangen, dass der Shellcode an sich schon signifikant kleiner ist als ein PE File und eine kleine Veränderung in einer Operation nicht zwangsläufig die Veränderung des gesamten Files korrumpiert.
\subsection{Kriterien}
\label{Methode:Kriterien}
\textit{Der vorgeschlagene Genetische Algorithmus ist in der Lage die Anforderungen an Laufzeit und Ergebnisse des Red-Teamings zu erfüllen.}
\subsection{Multi Obfuscated}
\textit{Die Anzahl der Obfuskationsschritte hat einen Einfluss auf die Erkennungswahrscheinlichkeit der Payload.} (Positiv, negativ o.ä. Als einzelne Gruppen interpretieren je nach Länge)
\subsection{Shell Access}
\textit{Evaded Shellcode Zeug führt in weniger als 50\% der Fälle zu tatsächlichem Shell Access}



