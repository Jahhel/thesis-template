\chapter{Theorie}
\label{chapter:theorie}

\section{Malware Erkennung}
Malware wird komplexer \cite{pascalmaniriho_2023_a}  und damit wird die Herausforderung der Erkennung von Malware ebenso komplexer. Heute geht man soweit, dass Malwareerkennung ein NP Vollständiges Problem ist \cite{ aslan_2020_a,pascalmaniriho_2023_a} und keine Malware Software alle Varianten beliebiger Malwareklassen und Familien erkennen kann \cite{aboaoja_2022_malware}, da neue Malware zunehmend Technologien nutz, um Malwareerkennung und Antivirenprogrammen zu entgehen (Verweis auf Section Malware Erkennung Umgehnung). Angefangen bei Methoden wie Obfuskierung, Packing, dynamischem Malware Verhalten und Fileless Malware \cite{aslan_2020_a}. 

Durch die große Verbreitung (71\% Windows 10, 23\% Windows 11 \cite{Klotz, A}) von Windows als Betriebssystem, wurde diese auch vermehrt ein Ziel von Angreifern, sodass die Entwicklung von Windowsmalware weit fortgeschritten ist und die größte Verbreitung hat \cite{aslan_2020_a}. Diese Entwicklung lässt den Schluss zu, dass auch Angreifer nach einer Maximierung ihrer Effizienz streben und den Großteil ihrer Zeit auf weit verbreitete Tools verwenden werden, sodass die häufigste AV Lösung diese sein wird, bei der die meisten Exploits gefunden werden können. Erste Schritte um mit diesen Problemen umzugehen waren bereits die Impfung von AV Software \cite{murali_2023_evolving} und das Training von ML Klassifikatoren mittels unrealistischer, wissenschaftlich generierter Malware Varianten \cite{dyrmishi_2023_on}.

\subsection{Analyse}
Der Erkennung von Malware liegt die Analyse von Dateien zugrunde, welche Faktoren wie den Datentyp, den Byte oder Optcode von Dateien in Betracht zieht und sich in dynamische, statische und Hybride Analysen aufteilen lässt \cite{aboaoja_2023_a}. Aus den daraus gewonnenen Eigenschaften wird dann eine Klassifikation von Dateien abgeleitet.
\subsubsection{Statische Analyse}
\label{analyse:statisch}
Statische Analysen operieren auf dem File ohne dieses File auszuführen. So können sie den Sourcecode und API-Calls in Betracht ziehen, Signaturen über Source- und Optcodes bilden, oder Signaturen über Abstraktionen, wie zum Beispiel die Abfolge von API Calls\cite{pascalmaniriho_2023_apimaldetect} bilden. Aber auch die Kompressionsrate oder die Entropie einer Datei, sowie die Header eines PE Files können hier einbezogen werden \cite{aboaoja_2023_a, aslan_2020_a}. 

\subsubsection{Dynamische Analyse}
\label{analyse:dynamisch}
Die dynamische Analyse basiert darauf, dass eine potentielle Malware in einer kontrollierten Umgebung, wie einer Sandbox, VM oder emulierten Maschiene ausgeführt und für eine begrenzte Zeit in ihrer Ausführung beobachtet wird\cite{aboaoja_2023_a}. Dabei können Memoryimages während der Laufzeit gemacht werden und Ausführungspfade mitsamt ihrer Edgcases abgedeckt werden, um Verhaltnesdaten während der Ausführung abzubilden. Der wichtige Punkt hieran ist, dass Obfuskatoren am Verhalten des ursprünglichen Programmes nichts ändern, sondern nur Verhalten hinzufügen \cite{alkhateeb_2023_a}. 

\subsubsection{Hybride Analysen}
\label{analyse:hybrid}
Hybride Analysen beinhalten Bestandteile aus \ref{analyse:dynamisch} und \ref{analyse:statisch}. Häufig sind sie in Tools zusammengefügt so wie in \cite{CAPE2}, die automatisierte Prozesse zur Verfügung stellen, um ein Automated Malware Evaluation bereitzustellen, die von einem gegebenen File eine Liste von Attributen und Eigenschaften dieser Datei zur Verfügung stellt. Dieser Bereich ist 

\subsection{Detektion}
Aus den generierten Features dieser Analyse setzen dann die sogenannten Malware Klassifikatoren an; diese teilen Dateien entweder in Gutartig (Benign) oder Bösartig (Malware) ein, oder gehen einen Schritt weiter und treffen Unterscheidungen nach Malwarefamilie und Klasse (z.B. Ransomware, Spyware, Wurm, ...).

\subsubsection{Klassische Klassifikation}
Klassischwerweise spaltet sich die Analyse in die vier Bereiche auf: 
\begin{itemize}
    \item Signatur-basiert
    \item Heuristik-basiert
    \item Verhaltens-basiert
    \item KI-basiert
\end{itemize}

Die \textit{signaturbasierten} Verfahren verlassen sich hauptsächlich auf eine aktuelle Datenbank von Signaturen von bekannter Malware. Diese Signaturen sind nicht notwendigerweise nur über das gesamte File sondern können auch nach bestimmten Sequenzen von API-Aufrufen oder Teilsignaturen beinhalten, um Malware zu erkennen. Dieser Ansatz funktioniert sehr effizient und verlässlich für bekannte Malware, die bereits im System vorhanden ist und erzeugt wenig bis keine False-Positives. Für Endanwender im privaten Kontext reichen diese häufig aus, da sie eine gute Base Level an Protection anbieten. (QUELLE!). 
\textit{Verhaltensbasierte} Klassifikationen stützten sich zu einem großen Teil auf die Auswertungen von dynamischen Analysen und ziehen Dinge in Betracht, wie die Ausführungsgraphen von einer Datei, den gemachten API Calls und den Zugriffen, die dieses Programm macht. Hierbei kann es schneller mal zu False Positives oder Negatives kommen, da eine starke Trennung von Benign und Malware dadurch erschwert wird, dass Malware Autoren ihre Programme der Struktur von Bengingware nachempfinden wollen. ((Quelle)
\textit{Heuristikbasierte} Verfahren, wie \cite{yara}, sind eine Kombination von verschiedenen Tools und geben die Möglichkeit vor spezifische Regeln zu definieren. So kann beispielsweise eine bestimmte Stringfolge in einer Malware in Kombination mit einem Call an eine IP Adresse, deren Location außerhalb des eigenen Landes liegt, als Malware klassifiziert werden. Diese Tools sind relativ weit benutzt, da sie einen hohen Aufwand mit sich bringen, sie zu definieren und zu konfigurieren, ohne die Gewissheit zu haben, inwieweit dies erfolgreich ist und damit häufig in Professionellen Kontexten verwendung findet. ((QUELLEN!)). Hierbei können beispielsweise sehr spezifische Angriffe reduziert oder gänzlich ausgeschlossen werden: So hat sich String erkennung gegen HTML-Tags und JavaScript basierte Angriffe als Erfolgreich erwiesen, DNS Basierte Regeln als Abwehr für Botnets etabliert. Ein anfängliches Thema ist die automatisierte Erstellung von Heuristiken mittels Machinelearnings. (QUELLE)

\textit{KI-Basierte} Malware Klassifikation ist in den letzten Jahren der Fokus der Wissenschaft geworden (QUELLE) und verspricht eine Möglichkeit zur Erkennung von unbekannten Malware Varianten anhand von Kombinationen aus den Daten der Analyse. Ein Nachteil und Schwierigkeit bei diesem Ansatz ist häufig eine mangelnde Erklärbarkeit und Einschätzung von Zuverlässigkeiten. Dies ist einer der Gründe, warum \cite{jiang_2024_benchmfc} Datensets für ebensolche Benchmarkings etabliert werden, um vergleichbare Datenlagen etablieren zu können. Ein weiteres Problem ist, dass diese Ansätze häufig sehr anfällig für Adversarial Example Angriffe sind, die in \ref{ML-Evasion} genauer betrachtet werden.

\section{Malware Erkennung Umgehung}
Viele kommerzielle Systeme arbeiten auch heute noch hauptsächlich signaturbasiert und erkennen keine neue Malware oder dies nur unzuverlässig mittels Heuristiken\cite{rathore_2023_breaking}, während Malwareautoren bereits kompliziertere Verfahren einführen, um die Analyse und Erkennung weiter zu erschweren \cite{nunes_2022_bane}. Dies vereinfacht ihre Arbeit, da sie dann nicht immer neue Tools entwickeln müssen, welche noch nicht von Sicherheitsforschern gefunden und katalogisiert wurden\cite{holm_2023_hide}. Um das automatisiert umzusetzen, gibt es eine Vielfalt von Tools zur Umgehung von Malwareerkennung oder zur Fehlklassifikation von Malwarefiles 


\subsection{Arten von Umgehungen}
Diese Methoden zur Umgehung von AV-Software lassen sich grob in drei große Bereiche aufteilen: Transformationsbasierte, Verschleierungsbasierte und Angriffsbasierte Strategien \cite{geng_2024_a}
\textit{Verschleierungsbasierte} Strategien basieren darauf, dass die Erkennungleistung erschwert wird, in dem Beispielsweise die Virtualisierung oder das Sandboxing erkannt wird; ebenso möglich sind das hinzufügen von langer Inaktivität  oder die Erkennung von menschlicher Präsenz, sodass eine Ausführung in einem Analysesetting nicht zu illegalem Verhalten der Malware führt, sondern sie sich in der Analyse wie Goodware verhält \cite{geng_2024_a}. Zusammen mit der \textit{Angriffsbasierten} Strategie wird sie manchmal auch unter dem Schlagwort Polymorphie \cite{elsersy_2022_the} zusammengefasst. Diese Strategie versucht aktiv gegen AV Software vorzugehen, indem sie die Prozesse beispielsweise beendet oder überlastet und so eine Klassifikation erschwert\cite{geng_2024_a}. 
Auf der anderen Seite und unter dem Schlagwort von \textit{metarmorphie}\cite{elsersy_2022_the} steht die \textit{Transformationsbasierte} Strategie, welche Obfuskatoren und Packer im klassischen Sinne, wie Nymcrypt2 und Inceptor beinhaltet. Diese verändern in der Regel nichts am Verhalten von Malware\cite{wauters_2024_building}, sondern sorgen dafür, dass sie andere Strukturen und damit Signaturen aufweisen, was die Klassifikation natürlich erschwert \cite{geng_2024_a}.

Aus diesem Bereich erstand dann auch der Forschungsbereich zur Generation von Malwarevarianten \cite{jin_2023_on}. Diese fokussieren sich darauf, durch Veränderungen an den Malwarefiles, bei gleichbleibender Auswirkung, neue Ausprägungen von Malware zu finden. Hierbei lassen sich Code Cave Optimization nennen, welche padding Bereiche in PE-Files\footnote{Windows Portable Executable} umschieben und die Werte darin zu verändern, um eine Missklassifikation herbeizuführen \cite{yuste_2022_optimization}. Ähnliche Ansätze sind im Bereich der Adversarial Attacks vorhanden, welche Ursprünglich aus dem Bilderkennungsbereich entstanden ist. Hierbei geht es darum, dass ein gegebes File (Beispielsweise das Bild eines Tucans) so verändert wird, dass ein trainierter Klassifikator (Computer Vision something), dass durch minimale Veränderung eine Fehlklassifikation herbeigeführt wird. So wird das Bild von dem Tukan plötzlich als Katze erkannt, obwohl für den menschlichen Beobachter keine Veränderung ersichtlich ist \cite{demetrio_2024_formalizing}. Dieses Verfahren wurde schließlich auch für die Malwareforschung übernommen und als Angriffsweg auf Machinelearning Klassifikatoren eingesetzt \cite{demetrio_2021_functionalitypreserving}. Dabei hat sich gezeigt, dass dieser Angriff für White-Box Modelle ausgesprochen effizient ist und für Black-Box Angriffe - also beispielsweise für kommerzielle Software - aufwändiger ist\cite{yuste_2022_optimization}. Aus diesem Grund werden für das Suchproblem von Adversarial Examples oder Permutationen häufig genetische Algorithmen verwendet\cite{demetrio_2021_functionalitypreserving}, da diese in kurzer Zeit einen großen Suchbereich abdecken können. \label{adversarial_example}

\section{Genetische Algorithmen}
\subsection{Genetische Algorithmen allgemein}
Genetische Algorithmen sind als Teilbereich von künstlicher Intelligenz ein lange bekanntes Feld in der Informatik. Sie finden bei Optimierungs- und Suchproblemen verschiedener Art Anwendung und liefern eine Balance aus Performance und Ergebnisqualität. Genetische Algorithmen sind nicht in der Lage für eine optimale Lösung zu garantieren, finden aber - bei guter Parametrisierung - eine gute Lösung in einem Bruchteil der Zeit, die eine vollständige Prüfung des Suchraums beanspruchen würde. Auf der anderen Seite sind sie als Konzept ebenso breit verbreitet wie Random Search, nur dass sie eine bessere Performance zeigen.

Genetische Algorithmen orientieren sich in ihrer Funktionsweise der Evolution und Genetik und reihen sich damit in das  Themenfeld des "Evolutionary Computings" ein.
Die zentralen Bestandteile eines genetischen Algorithmus sind die Repräsentation von Kandidaten, Selektion, Mutation, Rekombination und Fitness-Berechnung. Die Repräsentation beschreibt, wie ein Objekt, das als Lösung repräsentiert wird (z.B. Bitstring, geordnete Liste von Knoten, ...). Selektion beschreibt den Prozess, wie aus einer bestehenden Population (Generation) eine neue Generation ausgewählt wird, in der Art, dass diese mit hoher Wahrscheinlichkeit eine höhere durchschnittliche Fitness hat. Die Mutation verändert Aspekte der einzelnen Kandidaten, indem sie Veränderungen innerhalb der Repräsentation durchführt und so neues genetisches Material einbringt. Die Rekombination erklärt, wie zwei Lösungskandidaten sich reproduzieren und ihr vorhandenes genetisches Material miteinander rekombinieren, um zwei neue Kandidaten hervorzubringen. Die Fitnessfunktion ist die Funktion, die erklärt, wie gut ein gegebener Lösungskandidat ist.

Das klassische Beispiel für genetische Algorithmen ist das sogenannte Knapsack Problem, bei dem es eine Vielzahl an möglichen Items gibt, die man in diesen Rucksack packen kann. Diese Items haben verschiedene Gewichte und Wertigkeiten für die fiktive Reise. Das Suchproblem in diesem Fall ist es, die Konfiguration an Items zu finden, deren Gesamtgewicht das Maximalgewicht des Rucksacks nicht übersteigt und gleichzeitig die aufsummierte Wertigkeit maximiert.
In einem genetischen Algorithmus würden diese Items dann beispielsweise als Bitarray kodiert werden, wobei eine \"1\" an Index 0 dafür steht, dass man Item 0 einpackt und eine \"0\" an Index 12, dass man Item 12 nicht einpackt. Ein Bitstring aus 0 und 1, der die Länge der Itemliste hat, ist dann ein Encoding für die Lösungskandidaten. Eine Ansammlung von (z.B. 100) zufälligen Lösungskandidaten ist unsere initiale Generation. Diese werden anhand einer Fitnessfunktion bewertet. Ein häufiges Handwerkszeug dabei ist die Formel $ \frac{gute Eigenschaften}{schlechte Eigenschaften}$. In unserem Beispiel ist die Summe der Wertigkeit eine gute Eigenschaft, während die Summe der Gewichte und besonders das Überschreiten des Gewichtslimit schlechte Eigenschaften sind. Anhand dieser Fitnesswerte wird nun eine Selektion durchgeführt, durch die die besseren Kandidaten aus der initialen Generation wahrscheinlich häufiger in der nächsten Generation vorkommen. Diese neue Generation durchläuft nun nacheinander die Schritte Mutation und Rekombination. Bei der Mutation wird ein zufälliger Bruchteil der Lösungskandidaten verändert (z.B. ein Bitflip), um so neue Möglichkeiten abdecken zu können. Bei der Rekombination werden zwei Lösungskandidaten so miteinander kombiniert, dass bei gleichbleibenden Bits in der Gesamtmenge zwei neue Kandidaten entstehen. Durch eine Wiederholung dieser Prozesse (Selektion, Mutation, Rekombination) verbessert sich dadurch die durchschnittliche Fitness und beste Fitness pro Generation, bis zu dem Zeitpunkt, wo man den Algorithmus abbricht oder nahe genug an ein Maximum gekommen ist.

\subsection{Genetische Algorithmen in Bezug auf Malware}

Entweder als Tool zur Noise Generation \ref{adversarial_example}, Byte Substitution, Genetische Programmierung. Forschung soll sich auf Black Box Themen fokussieren, da sie in der Realität vorkommen. Auch gibt es das Thema von "real sinnvollen Attacken für Malware Defense 