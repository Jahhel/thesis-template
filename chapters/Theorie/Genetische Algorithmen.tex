\section{Genetische Algorithmen}
\label{Sec:GeneticAlgorithms}
\subsection{Einführung genetische Algorithmen}
Genetische Algorithmen sind als Teilbereich von künstlicher Intelligenz ein lange bekanntes Feld in der Informatik. Sie finden bei Optimierungs- und Suchproblemen verschiedener Art Anwendung und liefern eine Balance aus Performance und Ergebnisqualität. Genetische Algorithmen sind nicht in der Lage für eine optimale Lösung zu garantieren, finden aber - bei guter Parametrisierung - eine gute Lösung in einem Bruchteil der Zeit, die eine vollständige Prüfung des Suchraums beanspruchen würde. Auf der anderen Seite sind sie als Konzept ebenso breit verwendbar wie Random Search, nur dass sie eine bessere Performance zeigen.

Genetische Algorithmen orientieren sich in ihrer Funktionsweise an der Evolution und Genetik und reihen sich damit in das  Themenfeld des 'Evolutionary Computings' ein.
Die zentralen Bestandteile eines genetischen Algorithmus sind die Repräsentation von Kandidaten, Selektion, Mutation, Rekombination und Fitness-Berechnung. Die Repräsentation beschreibt, wie ein Objekt, das als Lösung repräsentiert wird (z.B. Bitstring, geordnete Liste von Knoten, ...). Selektion beschreibt den Prozess, wie aus einer bestehenden Population (Generation) eine neue Generation ausgewählt wird, in der Art, dass diese mit hoher Wahrscheinlichkeit eine höhere durchschnittliche Fitness hat. Die Mutation verändert Aspekte der einzelnen Kandidaten, indem sie Veränderungen innerhalb der Repräsentation durchführt und so neues genetisches Material einbringt. Die Rekombination erklärt, wie zwei Lösungskandidaten sich reproduzieren und ihr vorhandenes genetisches Material miteinander rekombinieren, um zwei neue Kandidaten hervorzubringen. Die Fitnessfunktion ist die Funktion, die erklärt, wie gut ein gegebener Lösungskandidat ist.

Das klassische Beispiel für genetische Algorithmen ist das sogenannte Knapsack Problem, bei dem es eine Vielzahl an möglichen Items gibt, die man in diesen Rucksack packen kann. Diese Items haben verschiedene Gewichte und Wertigkeiten für die fiktive Reise. Das Suchproblem in diesem Fall ist es, die Konfiguration an Items zu finden, deren Gesamtgewicht das Maximalgewicht des Rucksacks nicht übersteigt und gleichzeitig die aufsummierte Wertigkeit maximiert.
In einem genetischen Algorithmus würden diese Items dann beispielsweise als Bitarray kodiert werden, wobei eine \"1\" an Index 0 dafür steht, dass man Item 0 einpackt und eine \"0\" an Index 12, dass man Item 12 nicht einpackt. Ein Bitstring aus 0 und 1, der die Länge der Itemliste hat, ist dann ein Encoding für die Lösungskandidaten. Eine Ansammlung von (z.B. 100) zufälligen Lösungskandidaten ist unsere initiale Generation. Diese werden anhand einer Fitnessfunktion bewertet. Eine häufig verwendete Faustregel dabei ist die Formel $ \frac{gute Eigenschaften}{schlechte Eigenschaften}$. In unserem Beispiel ist die Summe der Wertigkeit eine gute Eigenschaft, während die Summe der Gewichte und besonders das Überschreiten des Gewichtslimits schlechte Eigenschaften sind. Anhand dieser Fitnesswerte wird nun eine Selektion durchgeführt, durch die die besseren Kandidaten aus der initialen Generation wahrscheinlich häufiger in der nächsten Generation vorkommen. Diese neue Generation durchläuft nun nacheinander die Schritte Mutation und Rekombination. Bei der Mutation wird ein zufälliger Bruchteil der Lösungskandidaten verändert (z.B. ein Bitflip), um so neue Möglichkeiten abdecken zu können. Bei der Rekombination werden zwei Lösungskandidaten so miteinander kombiniert, dass bei gleichbleibenden Bits in der Gesamtmenge zwei neue Kandidaten entstehen. Durch eine Wiederholung dieser Prozesse (Selektion, Mutation, Rekombination) verbessert sich dadurch die durchschnittliche Fitness und beste Fitness pro Generation, bis zu dem Zeitpunkt, wo man den Algorithmus abbricht oder nahe genug an ein Maximum gekommen ist.

Die Funktion eines genetischen Algorithmus basiert auf dem sogenannten Schema Theorem, welches die Effektivität von Genetischen Algorithmen für Bitstrings bei einer kontinuierlichen Fitnessfunktion beweist \cite{holland_1992_adaptation}. Diese besagt, dass kurze Schemata mit hoher Fitness selten durch Mutation oder Rekombination zerstört werden und aus diesen 'Bausteinen', die relativ stabil sind, sich über die Laufzeit des Algorithmus eine Lösung aus guten Bausteinen zusammensetzt. Einen ähnlichen Ansatz verfolgen \cite{song_2022_mabmalware} in ihrer Untersuchung von Malwarevariaton.

\subsection{Genetische Algorithmen in Bezug auf Malware}
Genetische Algorithmen sind schon seit den 2019ern \cite{castro_2019_aimed} in Verwendung, um Malware unbemerkbar für AV Scanner zu machen. Dabei lassen sich verschiedene Ansätze unterscheiden.
\subsubsection{Adversarial Attack}
\label{Adversarial_Genetic_Algos}
Der größte Teil der Forschung mit genetischen Algorithmen lässt sich in den Bereich der Adversarial Attacks einordnen, der auch schon zu Beginn in Bezug gesetzt wurde zu nicht GA gestützten Algorithmen \cite{castro_2019_armed}. Dieser Ansatz beinhaltet viele verschiedene Veränderungsmöglichkeiten, welche weiterhin funktionale PE Files erzeugen.
% Erklären was Adversarial Attacks sind
Dies können zum Beispiel PE-Header Substitutions oder Modificationes sein \cite{demetrio_2021_adversarial} oder das Einfügen und Modifizieren von Codecaves in bestehende Dateien \cite{yuste_2022_optimization}. Alle diese Ansätze kämpfen mit dem Problem, dass zeitgleich eine Veränderung des Source oder Bytecodes herbeigeführt werden soll, auf der anderen Seite aber die Funktionsweise der Malware möglichst identisch beibehalten werdne soll \cite{demetrio_2021_functionalitypreserving}. Dies schränkt die möglichen Mutationen naturgemäß ein, während die Ausführungszeit zur Prüfung der Lauffähigkeit und Intention der Software sich negativ auf die Praktikabilität auswirkt. 
Weiter lässt sich feststellen, dass der Großteil diesartiger Forschung zu dem Schluss gekommen ist, dass Adversarial Attacks auf White Box AV Software simpel und effizient umzusetzen sind, der Fokus der Forschung sich daher auf Black Box und damit auch auf kommerzielle Tools konzentrieren soll, um den Angriffsprozess besser nachbilden zu können.
\subsubsection{Simulation von Angreiferverhalten}
Ein anderer Ansatz, der nur wenig Beachtung erfahren hat, ist die Simulation von Angreifern im Netz durch eine Nachbildung von Angreifern und Verteidigern in einem Netzwerk mittels coevolutionärer Mittel \cite{alejandro_2024_a}.
\subsubsection{Defensive}
%QUellen suchen
Bisher werden GAs auch dafür verwendet, um bestehende AV Software zu verbessern und so zum Beispiel die Parameter für ML Erfassung zu optimieren \cite{xie_2023_gastackingmd}.
