\section{Malware Erkennung}
\label{Sec:Malwaredetektion}
Malware wird zunehmend komplexer \cite{pascalmaniriho_2023_a}  und damit wird die Herausforderung der Erkennung von Malware ebenso komplexer. Heute geht man soweit,  Malware\-erkennung als ein NP vollständiges Problem anzusehen \cite{ aslan_2020_a,pascalmaniriho_2023_a} und vermutet, dass keine AV-Software alle Varianten beliebiger Malwareklassen und Familien erkennen kann \cite{aboaoja_2022_malware}. Dies liegt daran, dass neue Malware zunehmend automatisierte und resourcenschonende Technologien nutzt, um Malwareerkennung und Antivirenprogrammen zu entgehen (vgl. \ref{Sec:MalwareEvasion}).

Durch die große Verbreitung  von Windows als Desktop- und Laptop-Betriebssystem,(71\% Windows 10, 23\% Windows 11 \cite{klotz_2023_windows}) wurde diese auch vermehrt ein Ziel von Angreifern, sodass die Entwicklung von Windows\-malware weit fortgeschritten ist und die größte Verbreitung hat \cite{aslan_2020_a}. Diese Entwicklung lässt auch den Schluss zu, dass Angreifer nach einer Maximierung ihrer Effizienz streben und den Großteil ihrer Zeit auf weit verbreitete Tools verwenden werden, sodass die häufigste AV Lösung diese sein wird, bei der die meisten Exploits gefunden werden. Erste Schritte um mit diesen Problemen umzugehen, waren bereits die 'Impfung' von AV Software mittels Malwarevarianten \cite{murali_2023_evolving} und das Training von ML Klassifikatoren mittels unrealistischer, wissenschaftlich generierter Malware Varianten \cite{dyrmishi_2023_on}.

\subsection{Analyse}
Der Erkennung von Malware liegt die Analyse von Dateien (Files) zugrunde, welche Faktoren wie den Datentyp, den Byte oder Optcode von Dateien in Betracht zieht und sich in dynamische, statische und Hybride Analysen aufteilen lässt \cite{aboaoja_2023_a}. Aus den daraus gewonnenen Eigenschaften wird dann eine Klassifikation von Dateien abgeleitet.
\subsubsection{Statische Analyse}
\label{analyse:statisch}
Statische Analysen operieren auf dem File ohne dieses auszuführen. So können sie den Sourcecode und API-Calls in Betracht ziehen, Signaturen über Source- und Optcodes bilden oder Signaturen über Abstraktionen, wie zum Beispiel die Abfolge von API Calls\cite{pascalmaniriho_2023_apimaldetect} bilden. Aber auch die Kompressionsrate oder die Entropie einer Datei sowie die Header eines PE Files können hier einbezogen werden \cite{aboaoja_2023_a, aslan_2020_a}. Dies liegt daran, dass Packer und Verschlüsselung die Kompression und Entropie von Dateien erhöhen und damit Anzeichen für Evasionsstrategien sind \cite{nunes_2022_bane}.

\subsubsection{Dynamische Analyse}
\label{analyse:dynamisch}
Die dynamische Analyse basiert darauf, dass eine potentielle Malware in einer kontrollierten Umgebung, wie einer Sandbox, VM oder (emulierten) Maschiene ausgeführt und für eine begrenzte Zeit in ihrer Ausführung beobachtet wird\cite{aboaoja_2023_a}. Dabei können Memoryimages während der Laufzeit gemacht werden und Ausführungspfade mitsamt ihrer Edgcases abgedeckt werden, um Verhaltensdaten während der Ausführung abzubilden. Der wichtige Punkt hieran ist, dass Obfuskatoren am Verhalten des ursprünglichen Programmes nichts ändern, sondern nur Verhalten hinzufügen \cite{alkhateeb_2023_a}. 
Dies hapert hauptsächlich daran, dass die Analysezeit begrenzt ist oder das Sandboxing erkannt werden kann, sodass die Malware einfach nicht ihrem böswilligen Zweck nachkommt, sondern inaktiv bleibt.

\subsubsection{Hybride Analysen}
\label{analyse:hybrid}
Hybride Analysen beinhalten Bestandteile aus \ref{analyse:dynamisch} und \ref{analyse:statisch}. Häufig sind sie in Tools zusammengefügt, so wie in \cite{oreilly_2022_cape}, die automatisierte Prozesse zur Verfügung stellen, um eine Automated Malware Evaluation bereitzustellen, die von einem gegebenen File eine Liste von Attributen und Eigenschaften dieser Datei zur Verfügung stellt. Dieser Bereich ist noch recht wenig untersucht und in Verwendung für den praktischen Einsatz aufgrund der einhergehenden Ressourcen- und Zeitaufwände.

\subsection{Detektion}
Aus den generierten Features dieser Analyse setzen dann die sogenannten Malware Klassifikatoren an; diese teilen Dateien entweder in Gutartig (Benign) oder bösartig (Malware) ein, oder gehen einen Schritt weiter und treffen Unterscheidungen nach Malwarefamilie und Klasse (z.B. Ransomware, Spyware, Wurm, ...) (QUELLE). Eine funktionale Unterscheidung ist ebenso möglich in die drei Gruppen, die auch für den Rest dieser Arbeit verwendet werden. Hierbei wird zwischen Benignware (Software ohne böswillige oder verdächtige Aktivitäten), Self-Sustaining Malware (Software, die ihre bösen Absichten selbstständig durchführt ohne Interaktion zu benötigen) und Interaktive Malware (Malware, die dem Angreifer interaktiven Zugriff auf das Gerät bietet z.B. Reverse Shell). Diese werden im weiteren gemäß ihrer Funktion referenziert. So wird 'Helloworld' als Beispiel für Benignware, 'Calc' als Beispiel für einen Windows API Call verwendet, der self-sustaining ist und 'Shell' bzw. 'Reverse-Shell' als interaktive Malware.

Klassischwerweise spaltet sich die Analyse in die vier Bereiche auf: 
Die \textit{signaturbasierten} Verfahren verlassen sich hauptsächlich auf eine aktuelle Datenbank von Signaturen von bekannter Malware. Diese Signaturen sind nicht notwendigerweise über das gesamte File berechnet, sondern können auch über bestimmten Sequenzen von API-Aufrufen oder Teile des Files berechnet werden, um Malware zu erkennen. Dieser Ansatz funktioniert sehr effizient und verlässlich für bekannte Malware, die bereits im System vorhanden ist und erzeugt wenig bis keine False-Positives. Für Endanwender im privaten Kontext reichen diese häufig aus, insofern sie die Signaturdatenbank aktuell halten und sich nicht als Angriffsziel von fokussierten und neuartigen Malwareaktueren sehen. 
\textit{Verhaltensbasierte} Klassifikationen stützten sich zu einem großen Teil auf die Auswertungen von dynamischen Analysen und ziehen Dinge in Betracht, wie die Ausführungsgraphen von einer Datei, den gemachten API Calls und den Zugriffen, die dieses Programm macht. In der Regel setzen sie diese Auswertungen anhand von gesammelten Daten in Bezug zu bekannter Malware. Hierbei kann es schneller mal zu False Positives oder Negatives kommen, da eine starke Trennung von Benign und Malware dadurch erschwert wird, dass Malware in ihrem Verhalten, Inhalt und Struktur von Benignware nachempfunden wird \cite{rathore_2023_breaking} .
\textit{Heuristikbasierte} Verfahren, wie YARA Regeln \cite{yara}, sind eine Kombination von verschiedenen Tools und geben die Möglichkeit vor spezifische Regeln zu definieren. So kann beispielsweise eine bestimmte Stringfolge in einer Malware in Kombination mit einem Call an eine IP Adresse, deren Location außerhalb des eigenen Landes liegt, als Malware klassifiziert werden. Diese Tools sind performanter als eine reine signaturbasierte Detektion. Sie benötigen allerdings auch mehr fachliche Kompetenz, da falsche YARA Regeln zur Fehlklassifikation von Malware führen können. Aus diesem Grund finden sie häufig in Industrie Kontexten Verwendung \cite{lockett_2021_assessing,yara}. Hierbei können beispielsweise sehr spezifische Angriffe reduziert oder gänzlich ausgeschlossen werden: So hat sich Stringerkennung gegen HTML-Tags und JavaScript basierte Angriffe als erfolgreich erwiesen, DNS Basierte Regeln als Abwehr für Botnets etabliert. Ein neu aufkommendes Thema in der Forschung ist die automatisierte Erstellung von heuristischen Regeln mittels Machinelearnings \cite{li_2024_automatically}.

\textit{KI-Basierte} Malware Klassifikation ist in den letzten Jahren der Fokus der Wissenschaft geworden \cite{fatemehdeldar_2023_deep, pascalmaniriho_2023_apimaldetect} und verspricht eine Möglichkeit zur Erkennung von unbekannten Malware Varianten anhand von Kombinationen aus den Daten der Analyse. Ein Nachteil und Schwierigkeit bei diesem Ansatz ist häufig eine mangelnde Erklärbarkeit und Einschätzung von Zuverlässigkeiten. Dies ist einer der Gründe, warum \cite{jiang_2024_benchmfc} Datensets für ebensolche Benchmarkings etabliert werden, um vergleichbare Datenlagen etablieren zu können. Ein weiteres Problem ist, dass diese Ansätze häufig sehr anfällig für Adversarial  Attacks sind, die in \ref{adversarial_example} genauer betrachtet werden.